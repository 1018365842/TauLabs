\hypertarget{namespacestring}{\section{string Namespace Reference}
\label{namespacestring}\index{string@{string}}
}


Provides Py\-Mite's string module.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacestring_a50fe3b7796f9e51ae833a1f4f812132c}{atoi}
\item 
def \hyperlink{namespacestring_ad6aec6f0982de66a4c1d3e737bc9ee80}{count}
\item 
def \hyperlink{namespacestring_af1d551a6a31bb5ebb75988b603b8edbd}{find}
\item 
def \hyperlink{namespacestring_aacab35511a4384892626ee960868777f}{join}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
string \hyperlink{namespacestring_aee808fa2139026484af927957ed5633f}{digits} = \char`\"{}0123456789\char`\"{}
\item 
string \hyperlink{namespacestring_a529be5ca3e660d5529dd7c543d5d93ca}{hexdigits} = \char`\"{}0123456789abcdef\-A\-B\-C\-D\-E\-F\char`\"{}
\item 
string \hyperlink{namespacestring_a6c44b858e17ad0eb81b82cc34119f3e1}{letters} = \char`\"{}abcdefghijklmnopqrstuvwxyz\-A\-B\-C\-D\-E\-F\-G\-H\-I\-J\-K\-L\-M\-N\-O\-P\-Q\-R\-S\-T\-U\-V\-W\-X\-Y\-Z\char`\"{}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Provides Py\-Mite's string module. 

\subsection{Function Documentation}
\hypertarget{namespacestring_a50fe3b7796f9e51ae833a1f4f812132c}{\index{string@{string}!atoi@{atoi}}
\index{atoi@{atoi}!string@{string}}
\subsubsection[{atoi}]{\setlength{\rightskip}{0pt plus 5cm}def string.\-atoi (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b}
\end{DoxyParamCaption}
)}}\label{namespacestring_a50fe3b7796f9e51ae833a1f4f812132c}
\begin{DoxyVerb}__NATIVE__
pPmObj_t pa;
pPmObj_t pb;
char const *pc;
char *pend;
long i;
int8_t base;
pPmObj_t pi;
PmReturn_t retval = PM_RET_OK;

/* Raise TypeError if it's not a string or wrong number of args, */
pa = NATIVE_GET_LOCAL(0);
if ((OBJ_GET_TYPE(pa) != OBJ_TYPE_STR) || (NATIVE_GET_NUM_ARGS() < 1)
    || (NATIVE_GET_NUM_ARGS() > 2))
{
    PM_RAISE(retval, PM_RET_EX_TYPE);
    return retval;
}

/* Get the base, if it exists; otherwise assume 10 */
base = 10;
if (NATIVE_GET_NUM_ARGS() == 2)
{
    pb = NATIVE_GET_LOCAL(1);

    /* Raise a TypeError if 2nd arg is not an int */
    if (OBJ_GET_TYPE(pb) != OBJ_TYPE_INT)
    {
        PM_RAISE(retval, PM_RET_EX_TYPE);
        return retval;
    }

    base = ((pPmInt_t)pb)->val;

    /* Raise ValueError if base is out of range */
    if ((base < 0) || (base == 1) || (base > 36))
    {
        PM_RAISE(retval, PM_RET_EX_VAL);
        return retval;
    }
}

/* Perform conversion */
pend = C_NULL;
pc = (char const *)&(((pPmString_t)pa)->val);
i = strtol(pc, &pend, base);

/* Raise ValueError if there was a conversion error */
if (*pend != C_NULL)
{
    PM_RAISE(retval, PM_RET_EX_VAL);
    return retval;
}

/* Create an int object to hold the result of the conversion */
retval = int_new(i, &pi);

NATIVE_SET_TOS(pi);

return retval;
\end{DoxyVerb}
 

Definition at line 35 of file string.\-py.

\hypertarget{namespacestring_ad6aec6f0982de66a4c1d3e737bc9ee80}{\index{string@{string}!count@{count}}
\index{count@{count}!string@{string}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}def string.\-count (
\begin{DoxyParamCaption}
\item[{}]{s1, }
\item[{}]{s2}
\end{DoxyParamCaption}
)}}\label{namespacestring_ad6aec6f0982de66a4c1d3e737bc9ee80}
\begin{DoxyVerb}__NATIVE__
pPmObj_t ps1;
pPmObj_t ps2;
uint8_t *pc1;
uint8_t *pc2;
uint8_t *pscan;
uint8_t *pmatch;
uint8_t pc2c0;
uint16_t pc1len;
uint16_t pc2len;
uint16_t n;
uint16_t remaining;
uint16_t cmp;
pPmObj_t pn;
PmReturn_t retval = PM_RET_OK;

/* Raise TypeError if it's not a string or wrong number of args, */
ps1 = NATIVE_GET_LOCAL(0);
ps2 = NATIVE_GET_LOCAL(1);
if ((OBJ_GET_TYPE(ps1) != OBJ_TYPE_STR) || (NATIVE_GET_NUM_ARGS() != 2)
    || (OBJ_GET_TYPE(ps2) != OBJ_TYPE_STR))
{
    PM_RAISE(retval, PM_RET_EX_TYPE);
    return retval;
}

pc1 = ((pPmString_t)ps1)->val;
pc2 = ((pPmString_t)ps2)->val;
pc1len = ((pPmString_t)ps1)->length;
pc2len = ((pPmString_t)ps2)->length;
n = 0;

/* Handle some quick special cases (order of if-clauses is important) */
if (pc2len == 0)
{
    n = pc1len + 1;
}
else if (pc1len == 0)
{
    n = 0;
}

/* Count the number of matches */
else
{
    n = 0;
    remaining = pc1len;
    pscan = pc1;
    pc2c0 = pc2[0];
    while (pscan <= (pc1 + (pc1len - pc2len)))
    {
        /* Find the next possible start */
        pmatch = (uint8_t *)memchr(pscan, pc2c0, remaining);
        if (pmatch == C_NULL) break;
        remaining -= (pmatch - pscan);
        pscan = pmatch;

        /* If it matches, increase the count, else try the next char */
        cmp = memcmp(pscan, pc2, pc2len);
        if (cmp == 0)
        {
            n++;
            pscan += pc2len;
            remaining -= pc2len;
        }
        else
        {
            pscan++;
            remaining--;
        }
    }
}

retval = int_new(n, &pn);

NATIVE_SET_TOS(pn);

return retval;
\end{DoxyVerb}
 

Definition at line 104 of file string.\-py.

\hypertarget{namespacestring_af1d551a6a31bb5ebb75988b603b8edbd}{\index{string@{string}!find@{find}}
\index{find@{find}!string@{string}}
\subsubsection[{find}]{\setlength{\rightskip}{0pt plus 5cm}def string.\-find (
\begin{DoxyParamCaption}
\item[{}]{s1, }
\item[{}]{s2}
\end{DoxyParamCaption}
)}}\label{namespacestring_af1d551a6a31bb5ebb75988b603b8edbd}
\begin{DoxyVerb}__NATIVE__
pPmObj_t ps1;
pPmObj_t ps2;
uint8_t *pc1;
uint8_t *pc2;
uint8_t *pmatch;
uint8_t pc1len;
uint8_t pc2len;
int32_t n;
pPmObj_t pn;
PmReturn_t retval = PM_RET_OK;

/* Raise TypeError if it's not a string or wrong number of args, */
ps1 = NATIVE_GET_LOCAL(0);
ps2 = NATIVE_GET_LOCAL(1);
if ((OBJ_GET_TYPE(ps1) != OBJ_TYPE_STR) || (NATIVE_GET_NUM_ARGS() != 2)
    || (OBJ_GET_TYPE(ps2) != OBJ_TYPE_STR))
{
    PM_RAISE(retval, PM_RET_EX_TYPE);
    return retval;
}

pc1 = ((pPmString_t)ps1)->val;
pc2 = ((pPmString_t)ps2)->val;
pc1len = ((pPmString_t)ps1)->length;
pc2len = ((pPmString_t)ps2)->length;
n = -1;

/* Handle a quick special case */
if (pc2len == 0)
{
    n = 0;
}

/* Try to find the index of the substring */
else
{
    /* Find the next possible start */
    pmatch = (uint8_t *)memchr(pc1, pc2[0], pc1len);
    if (pmatch != C_NULL)
    {
        /* If it matches, calculate the index */
        if (memcmp(pmatch, pc2, pc2len) == 0)
        {
            n = pmatch - pc1;
        }
    }
}

retval = int_new(n, &pn);

NATIVE_SET_TOS(pn);

return retval;
\end{DoxyVerb}
 

Definition at line 191 of file string.\-py.

\hypertarget{namespacestring_aacab35511a4384892626ee960868777f}{\index{string@{string}!join@{join}}
\index{join@{join}!string@{string}}
\subsubsection[{join}]{\setlength{\rightskip}{0pt plus 5cm}def string.\-join (
\begin{DoxyParamCaption}
\item[{}]{s, }
\item[{}]{sep = {\ttfamily '~'}}
\end{DoxyParamCaption}
)}}\label{namespacestring_aacab35511a4384892626ee960868777f}


Definition at line 250 of file string.\-py.



\subsection{Variable Documentation}
\hypertarget{namespacestring_aee808fa2139026484af927957ed5633f}{\index{string@{string}!digits@{digits}}
\index{digits@{digits}!string@{string}}
\subsubsection[{digits}]{\setlength{\rightskip}{0pt plus 5cm}string string.\-digits = \char`\"{}0123456789\char`\"{}}}\label{namespacestring_aee808fa2139026484af927957ed5633f}


Definition at line 26 of file string.\-py.

\hypertarget{namespacestring_a529be5ca3e660d5529dd7c543d5d93ca}{\index{string@{string}!hexdigits@{hexdigits}}
\index{hexdigits@{hexdigits}!string@{string}}
\subsubsection[{hexdigits}]{\setlength{\rightskip}{0pt plus 5cm}string string.\-hexdigits = \char`\"{}0123456789abcdef\-A\-B\-C\-D\-E\-F\char`\"{}}}\label{namespacestring_a529be5ca3e660d5529dd7c543d5d93ca}


Definition at line 27 of file string.\-py.

\hypertarget{namespacestring_a6c44b858e17ad0eb81b82cc34119f3e1}{\index{string@{string}!letters@{letters}}
\index{letters@{letters}!string@{string}}
\subsubsection[{letters}]{\setlength{\rightskip}{0pt plus 5cm}string string.\-letters = \char`\"{}abcdefghijklmnopqrstuvwxyz\-A\-B\-C\-D\-E\-F\-G\-H\-I\-J\-K\-L\-M\-N\-O\-P\-Q\-R\-S\-T\-U\-V\-W\-X\-Y\-Z\char`\"{}}}\label{namespacestring_a6c44b858e17ad0eb81b82cc34119f3e1}


Definition at line 28 of file string.\-py.

