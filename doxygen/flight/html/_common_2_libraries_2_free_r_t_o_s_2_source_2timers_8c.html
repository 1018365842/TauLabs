<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>TauLabs: /home/jose/Code/guiTau/flight/PiOS/Common/Libraries/FreeRTOS/Source/timers.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon_128x128.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TauLabs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">timers.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmr_timer_control.html">tmrTimerControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmr_timer_queue_message.html">tmrTimerQueueMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aed29d969267ced8c780ec770d1eea1a5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtmr_timer_control.html">tmrTimerControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#aed29d969267ced8c780ec770d1eea1a5">xTIMER</a></td></tr>
<tr class="separator:aed29d969267ced8c780ec770d1eea1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa2a4dae8c475b4108d8f39feb53e43"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtmr_timer_queue_message.html">tmrTimerQueueMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a2aa2a4dae8c475b4108d8f39feb53e43">xTIMER_MESSAGE</a></td></tr>
<tr class="separator:a2aa2a4dae8c475b4108d8f39feb53e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98436b7602c6fc3f8619af53f2442b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a98436b7602c6fc3f8619af53f2442b4b">xTimerCreate</a> (<a class="el" href="group___n_a_m_e.html#ga7ae6d0e43244213b34de2c2b9aa30da6">const</a> signed char *<a class="el" href="group___n_a_m_e.html#ga7ae6d0e43244213b34de2c2b9aa30da6">const</a> pcTimerName, <a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a> xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, <a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a> *pvTimerID, <a class="el" href="osx_2osx_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#aed251fe4d32d219374dc359ce7c84551">tmrTIMER_CALLBACK</a> pxCallbackFunction)</td></tr>
<tr class="separator:a98436b7602c6fc3f8619af53f2442b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6c8d4161c99a407c25248b34ad1715"><td class="memItemLeft" align="right" valign="top">portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#aad6c8d4161c99a407c25248b34ad1715">xTimerGenericCommand</a> (<a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a> xTimer, portBASE_TYPE xCommandID, <a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a> xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, <a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a> xBlockTime)</td></tr>
<tr class="separator:aad6c8d4161c99a407c25248b34ad1715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa498c494124776ef376a0f5e04b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2task_8h.html#a271ae40d5db07d928a113766505a0965">xTaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#af1aa498c494124776ef376a0f5e04b10">xTimerGetTimerDaemonTaskHandle</a> (<a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a>)</td></tr>
<tr class="separator:af1aa498c494124776ef376a0f5e04b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7c86e3a0126a2d7de1c72724858ee8"><td class="memItemLeft" align="right" valign="top">portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a6a7c86e3a0126a2d7de1c72724858ee8">xTimerIsTimerActive</a> (<a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a> xTimer)</td></tr>
<tr class="separator:a6a7c86e3a0126a2d7de1c72724858ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858c14351da9be4a9e48fee0749a879a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a858c14351da9be4a9e48fee0749a879a">pvTimerGetTimerID</a> (<a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a> xTimer)</td></tr>
<tr class="separator:a858c14351da9be4a9e48fee0749a879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aed29d969267ced8c780ec770d1eea1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtmr_timer_control.html">tmrTimerControl</a>  <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#aed29d969267ced8c780ec770d1eea1a5">xTIMER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2aa2a4dae8c475b4108d8f39feb53e43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtmr_timer_queue_message.html">tmrTimerQueueMessage</a>  <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a2aa2a4dae8c475b4108d8f39feb53e43">xTIMER_MESSAGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a858c14351da9be4a9e48fee0749a879a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a>* pvTimerGetTimerID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>void *pvTimerGetTimerID( xTimerHandle xTimer );</p>
<p>Returns the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used within the callback function to identify which timer actually expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to the timer being queried.</dd></dl>
<p>Example usage:</p>
<p>See the <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#addeaab31ad3bc4f880a5067a3c0e18b0">xTimerCreate()</a> API function example usage scenario. </p>

<p>Definition at line <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html#l00677">677</a> of file <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">timers.c</a>.</p>

</div>
</div>
<a class="anchor" id="a98436b7602c6fc3f8619af53f2442b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a> xTimerCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_a_m_e.html#ga7ae6d0e43244213b34de2c2b9aa30da6">const</a> signed char *<a class="el" href="group___n_a_m_e.html#ga7ae6d0e43244213b34de2c2b9aa30da6">const</a>&#160;</td>
          <td class="paramname"><em>pcTimerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a>&#160;</td>
          <td class="paramname"><em>xTimerPeriodInTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned portBASE_TYPE&#160;</td>
          <td class="paramname"><em>uxAutoReload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a> *&#160;</td>
          <td class="paramname"><em>pvTimerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="osx_2osx_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#aed251fe4d32d219374dc359ce7c84551">tmrTIMER_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>pxCallbackFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void * pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction );</p>
<p>Creates a new software timer instance. This allocates the storage required by the new timer, initialises the new timers internal state, and returns a handle by which the new timer can be referenced.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcTimerName</td><td>A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</td></tr>
    <tr><td class="paramname">xTimerPeriodInTicks</td><td>The timer period. The time is defined in tick periods so the constant portTICK_RATE_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_RATE_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</td></tr>
    <tr><td class="paramname">uxAutoReload</td><td>If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</td></tr>
    <tr><td class="paramname">pvTimerID</td><td>An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</td></tr>
    <tr><td class="paramname">pxCallbackFunction</td><td>The function to call when the timer expires. Callback functions must have the prototype defined by tmrTIMER_CALLBACK, which is "void vCallbackFunction( xTimerHandle xTimer );".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is successfully create then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then 0 is returned.</dd></dl>
<p>Example usage:</p>
<p>#define NUM_TIMERS 5</p>
<p>// An array to hold handles to the created timers. xTimerHandle xTimers[ NUM_TIMERS ];</p>
<p>// An array to hold a count of the number of times each timer expires. long lExpireCounters[ NUM_TIMERS ] = { 0 };</p>
<p>// Define a callback function that will be used by multiple timer instances. // The callback function does nothing but count the number of times the // associated timer expires, and stop the timer once the timer has expired // 10 times. void vTimerCallback( xTimerHandle pxTimer ) { long lArrayIndex; const long xMaxExpiryCountBeforeStopping = 10; </p>
<pre class="fragment">       // Optionally do something if the pxTimer parameter is NULL.
       configASSERT( pxTimer );

// Which timer expired?
lArrayIndex = ( long ) pvTimerGetTimerID( pxTimer );

// Increment the number of times that pxTimer has expired.
lExpireCounters[ lArrayIndex ] += 1;

// If the timer has expired 10 times then stop it from running.
if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
{
    // Do not use a block time if calling a timer API function from a
    // timer callback function, as doing so could cause a deadlock!
    xTimerStop( pxTimer, 0 );
}
</pre><p> }</p>
<p>void <a class="el" href="osd_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main( void )</a> { long x; </p>
<pre class="fragment">// Create then start some timers.  Starting the timers before the scheduler
// has been started means the timers will start running immediately that
// the scheduler starts.
for( x = 0; x &lt; NUM_TIMERS; x++ )
{
    xTimers[ x ] = xTimerCreate(     "Timer",         // Just a text name, not used by the kernel.
                                    ( 100 * x ),     // The timer period in ticks.
                                    pdTRUE,         // The timers will auto-reload themselves when they expire.
                                    ( void * ) x,     // Assign each timer a unique id equal to its array index.
                                    vTimerCallback     // Each timer calls the same callback when it expires.
                                );

    if( xTimers[ x ] == NULL )
    {
        // The timer was not created.
    }
    else
    {
        // Start the timer.  No block time is specified, and even if one was
        // it would be ignored because the scheduler has not yet been
        // started.
        if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
        {
            // The timer could not be set into the Active state.
        }
    }
}

// ...
// Create tasks here.
// ...

// Starting the scheduler will start the timers running as they have already
// been set into the active state.
xTaskStartScheduler();

// Should not reach here.
for( ;; );
</pre> 
<p>Definition at line <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html#l00220">220</a> of file <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">timers.c</a>.</p>

</div>
</div>
<a class="anchor" id="aad6c8d4161c99a407c25248b34ad1715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">portBASE_TYPE xTimerGenericCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a>&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">portBASE_TYPE&#160;</td>
          <td class="paramname"><em>xCommandID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a>&#160;</td>
          <td class="paramname"><em>xOptionalValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed portBASE_TYPE *&#160;</td>
          <td class="paramname"><em>pxHigherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_s_t_m32_f10x_2_libraries_2_free_r_t_o_s_2_source_2portable_2_g_c_c_2_a_r_m___c_m3_2portmacro_8h.html#a4d746b2ff8fafc490b764c66411ec457">portTickType</a>&#160;</td>
          <td class="paramname"><em>xBlockTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html#l00259">259</a> of file <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">timers.c</a>.</p>

</div>
</div>
<a class="anchor" id="af1aa498c494124776ef376a0f5e04b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2task_8h.html#a271ae40d5db07d928a113766505a0965">xTaskHandle</a> xTimerGetTimerDaemonTaskHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_a_m_e.html#ga18028b8badbf1ea7e704ccac3c488e82">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#af1aa498c494124776ef376a0f5e04b10">xTimerGetTimerDaemonTaskHandle()</a> is only available if INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p>Simply returns the handle of the timer service/daemon task. It it not valid to call <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#af1aa498c494124776ef376a0f5e04b10">xTimerGetTimerDaemonTaskHandle()</a> before the scheduler has been started. </p>

<p>Definition at line <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html#l00298">298</a> of file <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">timers.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6a7c86e3a0126a2d7de1c72724858ee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">portBASE_TYPE xTimerIsTimerActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2include_2timers_8h.html#ae889cfa94652a8294a73125af5d69846">xTimerHandle</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>portBASE_TYPE <a class="el" href="osx_2osx_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html#a6a7c86e3a0126a2d7de1c72724858ee8">xTimerIsTimerActive( xTimerHandle xTimer )</a>;</p>
<p>Queries a timer to see if it is active or dormant.</p>
<p>A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired on-shot timer that has not been restarted.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</dd></dl>
<p>Example usage:</p>
<p>// This function assumes xTimer has already been created. void vAFunction( xTimerHandle xTimer ) { if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )" { // xTimer is active, do something. } else { // xTimer is not active, do something else. } } </p>

<p>Definition at line <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html#l00658">658</a> of file <a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c_source.html">timers.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_1c0fe066ee3bbbff6911f1b6f0521ee4.html">flight</a></li><li class="navelem"><a class="el" href="dir_5a3d8bc9852988e902c2cb41a89fd797.html">PiOS</a></li><li class="navelem"><a class="el" href="dir_1ad632aa75fb2fa942c73a8375612937.html">Common</a></li><li class="navelem"><a class="el" href="dir_fcb909fa023d0e2eb51b3654d1c09422.html">Libraries</a></li><li class="navelem"><a class="el" href="dir_a9797ee7f5c0a8bc0adb05984e5dc9b5.html">FreeRTOS</a></li><li class="navelem"><a class="el" href="dir_4c5e1405f9e501660a5dd6ce4a1aba25.html">Source</a></li><li class="navelem"><a class="el" href="_common_2_libraries_2_free_r_t_o_s_2_source_2timers_8c.html">timers.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
